// File: Assets/Editor/ScenePathsGenerator.cs
#if UNITY_EDITOR
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using UnityEditor;
using UnityEditor.Callbacks;

namespace Infrastructure.EditorTools
{
    public static class ScenePathsGenerator
    {
        const string OUT_DIR = "Assets/Generated/Scenes";
        const string OUT_FILE = "ScenePaths.Generated.cs";
        const string CLASS_NAME = "ScenePaths";
        const string NAMESPACE = "Generated";

        [MenuItem("Infrastructure/Tools/Generate/ScenePaths (from Build Settings)")]
        public static void GenerateFromBuildSettingsMenu()
        {
            GenerateFromBuildSettings();
            AssetDatabase.Refresh();
            UnityEngine.Debug.Log($"[ScenePathsGenerator] Generated {Path.Combine(OUT_DIR, OUT_FILE)}");
        }

        public static void GenerateFromBuildSettings()
        {
            var scenes = UnityEditor.EditorBuildSettings.scenes
                .Where(s => !string.IsNullOrEmpty(s.path))
                .Select(s => s.path)
                .ToArray();

            Generate(scenes);
        }

        static void Generate(string[] scenePaths)
        {
            Directory.CreateDirectory(OUT_DIR);
            var map = new Dictionary<string, string>();

            foreach (var path in scenePaths)
            {
                // Assets/Scenes/Title.unity → Assets/Scenes/Title
                var noExt = path.Replace('\\', '/');
                if (noExt.EndsWith(".unity", StringComparison.OrdinalIgnoreCase))
                    noExt = noExt.Substring(0, noExt.Length - ".unity".Length);

                var name = Path.GetFileNameWithoutExtension(path);
                var id = MakeIdentifier(name);

                // 重複シーン対策
                if (map.ContainsKey(id))
                {
                    var i = 1;
                    var newId = "";
                    do
                    {
                        newId = $"{id}_{i++}";
                    } while (map.ContainsKey(newId));
                    id = newId;
                }

                map[id] = noExt;
            }

            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("// This file is auto-generated. Do not edit by hand.");
            sb.AppendLine($"// Generated: {DateTime.UtcNow:O}");
            sb.AppendLine();
            sb.AppendLine("namespace " + NAMESPACE);
            sb.AppendLine("{");
            sb.AppendLine($"    public static partial class {CLASS_NAME}");
            sb.AppendLine("    {");

            foreach (var kv in map)
            {
                sb.AppendLine($"        public const string {kv.Key} = \"{kv.Value}\";");
            }

            sb.AppendLine("    }");
            sb.AppendLine("}");

            var fullPath = Path.Combine(OUT_DIR, OUT_FILE).Replace('\\', '/');
            var newText = sb.ToString();

            if (File.Exists(fullPath))
            {
                var oldText = File.ReadAllText(fullPath);
                if (oldText == newText) return;
            }

            File.WriteAllText(fullPath, newText, Encoding.UTF8);
        }

        static string MakeIdentifier(string raw)
        {
            if (string.IsNullOrEmpty(raw)) return "_";
            var sb = new StringBuilder();
            for (int i = 0; i < raw.Length; i++)
            {
                var c = raw[i];
                if ((i == 0 && char.IsDigit(c)) || !IsIdentifierChar(c, i == 0))
                    sb.Append('_');
                else
                    sb.Append(c);
            }
            var candidate = sb.ToString();
            candidate = System.Text.RegularExpressions.Regex.Replace(candidate, @"\s+", "_");
            candidate = System.Text.RegularExpressions.Regex.Replace(candidate, @"[^0-9A-Za-z_]", "_");
            candidate = System.Text.RegularExpressions.Regex.Replace(candidate, @"_+", "_");
            if (char.IsDigit(candidate[0]))
                candidate = "_" + candidate;
            return candidate;
        }

        static bool IsIdentifierChar(char c, bool first)
        {
            if (first)
                return char.IsLetter(c) || c == '_';
            return char.IsLetterOrDigit(c) || c == '_';
        }
    }

    public class ScenePathsPostprocessor : AssetPostprocessor
    {
        static readonly string[] watchExtensions = { ".unity", "EditorBuildSettings.asset" };

        static void OnPostprocessAllAssets(
            string[] importedAssets, string[] deletedAssets,
            string[] movedAssets, string[] movedFromAssetPaths)
        {
            var need = importedAssets.Concat(deletedAssets).Concat(movedAssets).Concat(movedFromAssetPaths)
                .Any(path => watchExtensions.Any(ext => path.EndsWith(ext, StringComparison.OrdinalIgnoreCase)));

            if (need)
            {
                EditorApplication.delayCall += () =>
                {
                    try
                    {
                        ScenePathsGenerator.GenerateFromBuildSettings();
                        UnityEngine.Debug.Log("[ScenePathsPostprocessor] Regenerated ScenePaths.");
                    }
                    catch (Exception e)
                    {
                        UnityEngine.Debug.LogError("[ScenePathsPostprocessor] Failed to regenerate ScenePaths: " + e);
                    }
                };
            }
        }
    }
}
#endif
